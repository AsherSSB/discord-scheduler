<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="Content-Security-Policy"
          content="default-src 'self' https: blob: data:;
                   script-src 'self' 'unsafe-inline' 'unsafe-eval' 'wasm-unsafe-eval';
                   connect-src 'self' https: wss:;
                   img-src 'self' https: data: blob:;
                   style-src 'self' https: 'unsafe-inline';
                   worker-src 'self' blob:">
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>$GODOT_PROJECT_NAME</title>
    <link rel="icon" href="data:,">
    <style>
      html,body{height:100%;margin:0;background:#0b0b0b}
      #wrap{position:fixed;inset:0}
      #err{position:fixed;inset:12px;white-space:pre-wrap;color:#ff6b6b;font:13px/1.4 system-ui;display:none}
      canvas{width:100%;height:100%;display:block}
    </style>
  </head>
  <body>
    <div id="wrap">
      <canvas id="godot-canvas"></canvas>
    </div>
    <div id="err"></div>

    <script src="$GODOT_URL"></script>
    <script>
      const errBox = document.getElementById('err');
      const showEngineErr = (e) => {
        errBox.style.display = 'block';
        errBox.textContent = 'Godot startup error:\n' + (e?.stack || e);
        console.error(e);
      };
      const engine = new Engine($GODOT_CONFIG);
      const canvas = document.getElementById('godot-canvas');
      (engine.startGame?.() || engine.startGame)({ canvas })
        .then(() => console.log('Godot started'))
        .catch(showEngineErr);
      window.addEventListener('error', ev => showEngineErr(ev.error || ev.message));
      window.addEventListener('unhandledrejection', ev => showEngineErr(ev.reason || 'unhandled rejection'));
    </script>

    <script type="module">
      import { DiscordSDK } from "./vendor/discord-sdk/index.mjs";

      const errBox = document.getElementById('err');
      function showAuthErr(tag, e) {
        errBox.style.display = 'block';
        let msg = '';
        try { msg = e?.message || JSON.stringify(e, null, 2); }
        catch { msg = String(e); }
        errBox.textContent = `Discord auth error (${tag}):\n` + msg;
        console.error(tag, e);
      }

      (async () => {
        // 1) Get client + optional redirect from your server
        const infoResp = await fetch("/api/client-id");
        const info = await infoResp.json();
        if (!info.client_id) throw new Error("Missing client_id from /api/client-id");
        const client_id = info.client_id;
        const redirect_uri = info.redirect_uri || "";

        // 2) SDK ready
        const sdk = new DiscordSDK(client_id);
        await sdk.ready();

        // 3) Authorize: RPC-first (no redirect_uri). If Discord demands it, retry with redirect.
        let code;
        let usedRedirect = false;
        try {
          ({ code } = await sdk.commands.authorize({
            client_id,
            response_type: "code",
            state: "",
            prompt: "none",
            scope: ["identify","guilds","applications.commands"]
          }));
        } catch (e) {
          const m = (e && (e.message || e.toString())) || "";
          if (m.includes('Missing "redirect_uri"')) {
            if (!redirect_uri) throw new Error("No redirect_uri configured for fallback.");
            ({ code } = await sdk.commands.authorize({
              client_id,
              response_type: "code",
              state: "",
              prompt: "none",
              scope: ["identify","guilds","applications.commands"],
              redirect_uri
            }));
            usedRedirect = true;
          } else {
            return showAuthErr("authorize()", e);
          }
        }

        // 4) Exchange code (tell server if we used redirect_uri)
        let access_token;
        try {
          const r = await fetch("/api/authenticate", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ code, use_redirect_uri: usedRedirect })
          });
          const data = await r.json();
          if (!r.ok) return showAuthErr("token exchange", data);
          access_token = data.access_token;
        } catch (e) {
          return showAuthErr("fetch(/api/authenticate)", e);
        }

        // 5) Authenticate within the client
        try {
          await sdk.commands.authenticate({ access_token });
          console.log("Discord SDK authenticated in client.");
        } catch (e) {
          return showAuthErr("sdk.authenticate()", e);
        }

        // 6) Hand token to Godot in three ways to avoid races
        window.__discordAccessToken = access_token; // late-pull fallback
        window.dispatchEvent(new CustomEvent("discord-token", { detail: access_token })); // event bridge
        if (window.godotReceiveToken) {
          console.log("Forwarding token to Godot…");
          window.godotReceiveToken(access_token); // direct call if Godot registered
        } else {
          console.log("No godotReceiveToken yet (Godot still booting).");
        }
      })().catch(e => showAuthErr("top-level", e));
    </script>
  </body>
</html>
